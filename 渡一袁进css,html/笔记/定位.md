# 定位

定位：手动控制元素在包含块中的精准位置 

涉及css属性：position
## position
默认值 static,静态定位（不定位）
relative:相对定位
absolute:绝对定位
fixed：固定定位

一个元素，只要position的取值不是static，认为该元素是一个定位元素



一个脱离了文档流的元素：
1.文档流中元素摆放时，会忽悠脱离了文档流的元素
2.文档流中元素计算自动高度时，会忽略脱离了文档流的元素

## 相对定位
不会影响元素脱离文档流，只是让元素在原来位置上进行偏移，
原来浮动流，相对定位后还是浮动流，原来正常文本流，相对定位后还是正常文本流

相对定位下盒子的偏移不会对其他盒子造成任何影响，可以理解只是视觉效果的偏差，实际位置还是以前位置，在渲染布局步骤的最后一步才进行相对定位计算（个人理解）；

同时设置上下左右位置时，以上为准，以左为准。

## 绝对定位
absolute
1.盒模型宽高为auto,盒子尺寸是适应内容
2.包含快变化：找祖先元素中第一个定位元素。（除了static外都是定位元素），该元素的···填充盒···为其包含块,若找不到，则它的包含块为整个网页初始包含块，可以理解为整个html元素
相对定位通常为绝对定位提供包含块


## 固定定位
其他情况盒绝对定位一样；
包含块不同：固定为视口（浏览器的可视窗口）不会随着页面滚动而改变

固定或者绝对定位下的居中
某个方向居中：
1.定宽（高）
2.将左右（上下）距离设置为0
3.将左右（上下）margin设置为auto

绝对定位和固定定位下
margin会吸收剩余空间

堆叠上下文

简单说一下
设置z-index,通常情况下，该值越大，越靠近用户
***只有定位元素设置z-index有效
z-index可以是负数，如果是负数，则遇到常规流，浮动元素，则会被其覆盖。

## 补充
- 绝对定位，固定定位，一定是块盒
+   绝对定位，固定定位元素一定不是浮动
- 没有外边距合并 

## 透明
每个颜色都具有透明通道0~1
1.rgba(红，绿，蓝，alpha)
2.hex:#红绿蓝透

# 注意，常规流和浮动流的高度自动都会忽视浮动和绝对，固定定位流的盒子，想要适应浮动盒子需要清除浮动，要适应定位盒--把定位盒子改成常规流，或者使用flex布局。



gpt回答
虽然浮动（float）和绝对定位（position: absolute）或固定定位（position: fixed）都可以用来脱离文档流，但它们的本质和行为方式是不同的。

浮动（float）：当元素设置了浮动后，它会从正常的文档流中脱离出来，并且会向左或向右移动，直到遇到父元素或其他浮动元素的边界。在浮动流中，其他非浮动元素会围绕浮动元素进行布局。浮动元素的布局可能会受到周围内容的影响，需要使用清除浮动（clear float）技术来解决父元素塌陷等问题。

绝对定位（position: absolute）和固定定位（position: fixed）：当元素设置了绝对定位或固定定位后，它也会脱离正常的文档流并且相对于其最接近的已定位祖先元素（或根元素，对于固定定位）进行定位。绝对定位和固定定位的元素不会影响其他元素的布局，而其他元素也不会对它们产生影响。

尽管浮动和绝对定位/固定定位都可以导致元素脱离文档流，但它们创建的布局环境和对其他元素的影响是不同的。所以虽然浮动元素得到了一种称为"浮动流"的特定布局，但使用绝对定位或固定定位的元素没有浮动流的概念，因为它们不会对其他元素产生类似浮动元素的影响。

需要根据具体情况和需求选择使用浮动、绝对定位或固定定位，同时注意它们对布局和相邻元素的影响，以达到预期的效果






总结一下 
默认值
width:auto;
height:auto;
margin:0px;

正常文档流，块盒
默认值
width:auto;占满包含块，自动获取剩余宽度
height:auto;自适应内容高度
手动设置margin有效
margin:auto;时，左右自动占满包含块，上下为0；
正常文档流，行盒
默认值
不能手动设置宽高，需要间接设置行高，文字等相关样式
宽高根据内容变化而变化
margin,padding,border,水平方向有效，垂直方向能看见效果，但是不能占据空间
maring为auto,也都为0
正常文档流，行块盒
默认值
width:auto;自适应内容
height:auto,自适应内容
可以手动设置宽高，边距啥的
margin:auto; 都为0
浮动  浮动盒自动变为块盒
宽高 自适应
margin:auto;都为0；
可以设置边距
绝对或者固定定位(absolute,fixed)脱离文档流
宽高自适应
margin:auto;自动占满包含块宽度或者高度

宽高，外边距auto计算方式
再总结一下下
1.行盒不能设置宽高及上下边距不占空间
2.除了正常文档流的块盒宽度默认auto是吸收包含块剩余宽度，其他情况都是宽高自适应
3.除了文档流块盒margin的auto属性左右吸收包含块剩余以及（绝对或者固定，absolute或者fixed）定位属性marign:auot所有方向吸收包含块剩余宽度，其他情况都是0；

高度auto自动计算方式：
总结一下
三种视觉格式化模型都忽略定位流元素，常规流里还忽略掉了浮动流元素，宽度自动适应，（不考虑overflow属性BFC盒子）应该也一样，懒得试

默认排列方式：
总结一下（不考虑bfc）
定位和浮动都是BFC，会避开浮动元素
常规流块盒无视浮动元素，浮动元素避开常规流块盒
常规流行盒（匿名行盒）会避开浮动元素，浮动元素会无视常规流行盒（匿名行盒）
常规流无视定位盒，定位盒会在常规流下面一行开始排列（不确定，有例外）



可以这样理解定位，在外边距盒子外面又添加一层postion盒子，position盒子和外边距盒子一起占满包含块的宽度，

gpt
四个方向属性的默认值的计算规则如下：

top: auto：如果没有设置 top 属性的值，那么元素的上边距默认为 "auto"。这时，元素的顶部边界与含有它的块级容器的内容区域顶部边界相一致，遵循正常文档流的排列规则。

right: auto：如果没有设置 right 属性的值，那么元素的右边距默认为 "auto"。这时，元素的右侧边界与含有它的块级容器的内容区域右侧边界相一致，遵循正常文档流的排列规则。

bottom: auto：如果没有设置 bottom 属性的值，那么元素的下边距默认为 "auto"。这时，元素的底部边界与含有它的块级容器的内容区域底部边界相一致，遵循正常文档流的排列规则。

left: auto：如果没有设置 left 属性的值，那么元素的左边距默认为 "auto"。这时，元素的左侧边界与含有它的块级容器的内容区域左侧边界相一致，遵循正常文档流的排列规则。

总结来说，当四个方向属性设置为 "auto" 时，元素的边界会根据正常文档流的规则与父元素的内容区域相对齐。但请注意，这个默认行为可能会在特定情况下被其他因素（例如相对定位、浮动元素等）所影响。因此，在实际开发中，还是应该根据具体需求来显式地设置这些方向属性的值，以确保元素的准确布局与定位。
