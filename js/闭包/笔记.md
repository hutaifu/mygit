# 闭包
内部的声明函数被保存到了外部 ，一定生成闭包。
=》函数声明时作用域链根据当前环境确定确定，
闭包会导致 原有作用域链不释放 ，造成内存泄漏。=》函数执行完，但是函数的执行上下文不会被释放;

个人理解：函数可以嵌套，函数定义时根据当前环境产生作用域链，函数执行时函数产生函数自己的AO域放在函数自己作用域的顶端。函数执行完毕后就取消函数作用域链和函数执行产生AO域的关联，这时如果AO域没有被关联，就会释放。如果函数能够保证嵌套层级一直不变，根据这个规则，函数不管嵌套多少层，每个函数执行产生的AO域最终都会在当前层级被销毁。
但是闭包会改变函数嵌套层级，在函数执行完毕后，由于函数的AO域被返回到外面一层的内部函数关联，(内部函数的作用域链)，导致当前层级的函数执行完毕，但是函数的作用域没有被释放。

闭包作用；
1.实现公有变量
2.可以做缓存(存储结构)
3.实现封装化，实现私有化
4.模块化开发，防止污染全局变量。

# 立即执行函数，针对初始化功能的函数，只执行一次
(function (s,d,f){
    var a = 123;
    var b = 234;
    console.log(a + b);
}(1,2,3))
执行完就被销毁。不会占用内存。
只有表达式能被执行符号()执行，
被执行符号执行的表达式会忽略函数的名称。
+ function test(){
    console.log('a')
}();
+,-,!都能变成表达式，正，负，非。   && ，|| 也行，前面要有东西
(function test(){})()
(function test(){}())

      function test1(a,b,c,d){
            console.log("a")
        }(1) 这样写，不会报错，函数也不会执行，系统会把函数声明和括号分开。不再把括号认为执行符号。


十 对一 的闭包要立即得到实时变量只能用十对十的立即执行函数操作。


# 逗号操作符
var a = (2,3); // a = 3;
逗号操作符，返回后面表达式的结果；


var x = 1;
if(function f(){}){ //if会将括号里面值转成布尔类型，有六个值转成false,其余转成true,同时函数变成立即执行函数表达式，函数名不会被记录。
    x += typeof f; //未经声明的变量只有放到typeof里面不会报错；
}
console.log(x);