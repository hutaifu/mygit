+   请求库的封装
  + 背景
  + 真实的项目案例，基建，复杂问题，细节问题会被放大，开发周期长
  + 项目人数多，就需要基建，提升开发效率。
  + 不绑定上层实现

深度加工

虽然前端具有很多成熟的请求库，但是在项目实际开发中发现，很难契合实际的需求。没有提供诸多的上层实现功能。
axios:
1.请求重试。
2.请求缓存。（在一定时间，请求只能请求一次）
3.请求幂等。（重复提交问题）
4.请求串行。（一连串的请求，下一个请求由上一个请求决定怎么发）
5.请求并发。（多个请求同时发出）

VueRequset/SWR：虽然提供的功能多，但是仍然存在诸多的问题：
1.与上次框架过度绑定，使用场景受限。无法提供统一的API.
2.成熟度不够，issue的回复也难以做到及时，存在一定的风险。
3.它们没有聚合基础请求库，仍然需要手动整合。

公共库不包含内部制定的协议规范，即使使用公共库，也必须针对它们做二次封装。

综上，需要自行封装一套适配公司业务的请求库。

方案和实现

库结构的宏观设计

请求实现层axios/fetch/xhr --> request-core(核心层)  --->  request-business(业务层)    request-lib 

问题：实现层可以选择多种方式，到底使用哪一种不好判断，我希望实现层的可以是动态改变的，并且不影响核心层和业务层。

必须寻求一种方案来隔离这种不稳定性。
可以基于DIP，依赖倒置原则，彻底将request-core解耦，ts的类型系统让这一切落地成为了可能。

代码结构变为
request-imp  实现---->  接口  <-----依赖 request-core  <-----  request-business  
(核心层只定义接口，不负责实现，核心层依赖接口，想要使用核心层就必须实现接口，具体接口的实现方式，核心层不关注)
本质上，是核心层规定了实现基础功能时接受参数类型和输出参数的类型，本质上就时添加了一个中间层，这个中间层将方法的具体实现
和核心层解耦。
接口的作用之一，方便后续对方法的实现进行修改，同时不会影响后续的逻辑。将方法的实现和方法功能进行结构。

开闭原则：软件进行修改，只能新增代码，而不是修改原有代码。

请求缓存
创建一个带有缓存的请求，当没有命中缓存时发送请求并请求缓存结果，当有缓存时，请求就返回缓存。

实现此功能需要考虑几个核心问题：
请求结果怎么存储？，缓存键是什么？
希望用户能够指定缓存方案（内存/持久化），同时也能指定缓存键。又不稳定了，
凡是不稳定的地方，就给他中间夹一层，没有什么是中间夹一层解决不了的。有的话，就
再加一个中间层。具体功能 ---》 依赖统一接口，接口的实现功能不管。
缓存时根据传递的参数，来创建不同存储的方案。

缓存何时失效，基于时间函数其他条件
//根据时间
//根据键

请求幂等
f(n) = 1^n   ,无论n的值是多少，f(n)不变为1。
网络请求中，很多接口都要求幂等性，其实就是请求的重复提交。
关键问题：定义什么是重复？ 
重复的定义，请求方法，请求头，请求体完全一致。
因此，我们可以使用hash将它们编码成一个字符串。


通过维护接口文档生成一个json字符串，然后通过nodejs构建一个生成样本代码的
工具。


项目名：做过的真是项目
岗位：高级前端工程师
项目介绍：
项目职责：
参与项目的通用库开发
项目亮点：
从0到1开发整个请求库，以适配项目开发遇到的请求场景，例如请求并发，串行，幂等，缓存等。同时包含自当化工具，
用于根据接口文档生成请求样板代码。

请求库不仅完全消除了不同框架重复的请求代码，极大的缩短了接口联调的时间，为业务开发
提效30%，同时带来的更高的可维护性。



































