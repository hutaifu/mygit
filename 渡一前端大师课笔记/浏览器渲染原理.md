渲染render
hetml 文档字符串 --》像素信息
网络进程 =》拿到html文档字符串 =》消息队列中生成渲染任务 =》渲染主线程取出渲染任务执行=》

html字符串=》解析html =>样式计算 =》布局 =》分块 =》绘制 =》分层=》光栅化=》画
1.解析html
html字符串 =》dom树和cssOM树  变成树结构容易操作
css树 =》document.styleSheets;   存在link样式和style样式
开始解析前预先启动预解析线程 => 网络线程下载css => 预解析线程解析css=>返回渲染主线程
渲染主线程解析到link文件，如果预解析线程还未下载完全，继续解析不会阻塞
所以css不会阻塞html解析

但是碰到下载的js，会停止，等待js下载完成。

2.样式计算
css树和dom树结合。得到最终样式。
确定声明值 =》层叠 =》继承=》使用默认值
层叠=》1.比较源，2.比较优先级3.比较次序。

3.布局，根据样式计算得到元素的相对包含块位置，尺寸。
display:none不出出现在布局树。
dom树生成布局树：布局树会多出匿名行盒，伪元素，滚动条，等
布局树是c++对象，没有被js封装，无法全部获取。

4.分层 layer 提高渲染效率
哪一层发生变化，只改变那一层
不会分太多
滚动条和堆叠上下文有关的属性，会影响分层决策
will-change:transform;属性,表示哪些属性将来会发生变化，可以比较大的控制分层决测

5.绘制 paint
生成绘制指令集，为每一层单独生成绘制指令

以上都是渲染主线程工作：
解析=》样式计算=》布局=》分层=》绘制

6.分块 titing
渲染主线程将每个图层的绘制信息提交给合成线程
合成线程启动更多的分块线程，同时完成分块操作
将每一层分为多个小的区域；

7.光栅化
此过程用到GPU加速
合成线程启动GPU进程
GPU进程完成光栅化，优先处理靠近视口的，生成位图，交给合成线程
将每个块变成图，优先处理靠近视口的块。

8.画 draw;
合成线程拿到每个层，每个块的位图后，生成一个个指引信息，
指引标识出每个位图应该画到屏幕的哪个位置，以及考虑到图像旋转，缩放等变形，比如transform属性
合成线程将信息交给GPU进程，GPU进程控制硬件画出页面

什么是reflow？
js修改影响几何信息的样式或者操作dom=》修改dom树或者css树，触发布局及后面的操作；
设置css属性会产生一个异步渲染任务,不会立即执行reflow;
但是读取属性会立即触发一个同步的渲染任务，也就是会立即执行reflow;

什么是repaint；
当改动的属性和几何信息无关，比如字体颜色，背景颜色，不会触发布局，甚至分层也可能不会触发
本质根据分层的信息得到绘制指令。

当使用animation动态控制transfor属性，只会在最后一步画进行修改。




